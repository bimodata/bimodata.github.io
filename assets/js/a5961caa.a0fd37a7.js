"use strict";(self.webpackChunk_bimo_docs_website=self.webpackChunk_bimo_docs_website||[]).push([[8322],{2394:e=>{e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"r\xe9concilier-les-lieux-de-deux-syst\xe8mes-diff\xe9rents-avec-find-best-match-for-target-among-candidates","metadata":{"permalink":"/examples/r\xe9concilier-les-lieux-de-deux-syst\xe8mes-diff\xe9rents-avec-find-best-match-for-target-among-candidates","source":"@site/examples/r\xe9concilier-les-lieux-de-deux-syst\xe8mes-diff\xe9rents-avec-find-best-match-for-target-among-candidates.mdx","title":"R\xe9concilier les lieux de deux syst\xe8mes diff\xe9rents","description":"Le service Bimo findBestMatchForTargetAmongCandidates permet de trouver la meilleure association entre des objets par un syst\xe8me d\'it\xe9rations successives. Voici quelques exemples d\'utilisations de ce service:","date":"2022-12-13T00:00:00.000Z","tags":[{"inline":true,"label":"findBestMatchForTargetAmongCandidates","permalink":"/examples/tags/find-best-match-for-target-among-candidates"},{"inline":true,"label":"lieux","permalink":"/examples/tags/lieux"}],"hasTruncateMarker":false,"authors":[{"name":"Ga\xebl Ham\xe9on","title":"Cr\xe9ateur de Bimo","url":"https://github.com/gaelhameon","imageURL":"https://github.com/gaelhameon.png","key":"gael"}],"frontMatter":{"slug":"r\xe9concilier-les-lieux-de-deux-syst\xe8mes-diff\xe9rents-avec-find-best-match-for-target-among-candidates","title":"R\xe9concilier les lieux de deux syst\xe8mes diff\xe9rents","lead":"Le service Bimo `findBestMatchForTargetAmongCandidates` permet de trouver la meilleure association entre des objets par un syst\xe8me d\'it\xe9rations successives.","date":"2022-12-13","authors":["gael"],"tags":["findBestMatchForTargetAmongCandidates","lieux"],"hide_blog_post_date":true},"unlisted":false,"nextItem":{"title":"Cr\xe9er un nouveau service Bimo","permalink":"/examples/creation-du-service-get-bbox-for-place"}},"content":"import DescriptionProbleme from \'../mdx-snippets/description-probleme-must-hastus/fr.mdx\';\\n\\nLe service Bimo `findBestMatchForTargetAmongCandidates` permet de trouver la meilleure association entre des objets par un syst\xe8me d\'it\xe9rations successives. Voici quelques exemples d\'utilisations de ce service:\\n\\n- Trouver la variante (ou le _voyage mod\xe8le_) qui correspond le mieux \xe0 un voyage import\xe9 d\'un syst\xe8me maison pour ensuite enrichir ce voyage avec les infos de la variante (ou du _voyage mod\xe8le_)\\n- R\xe9concilier des listes de lieux sur la base de libell\xe9s qui varient l\xe9g\xe8rement. Par exemple: \\"Paris Nord\\" vs \\"Gare du Nord\\"\\n- Trouver le noeud ou l\'arc qui correspond le mieux \xe0 un lieu dans un graphe repr\xe9sentant le r\xe9seau\\n- ...\\n\\nChacune de ces utilisations est un peu abstraite et difficile \xe0 d\xe9crire en une phrase ... n\'h\xe9sitez pas \xe0 laisser un commentaire si vous aimeriez en savoir plus sur l\'une d\'entre elles.\\n\\nDans cet article, nous allons nous int\xe9resser \xe0 une utilisation relativement simple de ce service:\\n\\n- Trouver le lieu Hastus qui correspond le mieux \xe0 un lieu en provenance d\'un syst\xe8me maison\\n\\n## Probl\xe8me\\n\\n{/* Le probl\xe8me est le m\xeame que celui d\xe9crit dans <ArticleLink slug=\\"extraire-automatiquement-des-images-de-plans-de-voies-\xe0-partir-de-la-cartographie-hastus\\">cet article</ArticleLink>, mais on s\'int\xe9resse ici \xe0 une autre partie de la solution. */}\\n\\n<DescriptionProbleme />\\n\\nLe service `findBestMatchForTargetAmongCandidates` est parfait pour r\xe9pondre \xe0 ce type de probl\xe8me.\\n\\n## Aper\xe7u des donn\xe9es\\n\\n### Donn\xe9es du syst\xe8me maison\\n\\nLe seul \xe9l\xe9ment \\"standard\\" dans ces donn\xe9es est le code UIC8 de la gare. Ensuite, on trouve des id incr\xe9mentaux pour chaque voie, mais en y regardant de plus pr\xe8s, on se rend compte qu\'une m\xeame voie semble pouvoir exister avec plusieurs ID. Dans les exemples de donn\xe9es ci-dessous, les id 1 et 2 semblent tous deux d\xe9signer la voie B de Bellegarde, l\'une dans le sens Culoz vers Gen\xe8ve et l\'inverse pour l\'autre.\\n\\nOn trouve par ailleurs deux champs contenant:\\n\\n- le libell\xe9 \\"infra\\" de la voie (celui utilis\xe9 par les agents SNCF R\xe9seau)\\n- le libell\xe9 \\"commercial\\" de la voie (celui utilis\xe9 par les agents commerciaux et les passagers)\\n\\nPar exemple, dans les donn\xe9es ci-dessous, on voit qu\'\xe0 Libourne, la voie qui est connue comme voie B pour les passagers semble \xeatre connue comme voie 2 pour les agents SNCF R\xe9seau. Mais on voit \xe9galement que dans certains cas, le libell\xe9 commercial a \xe9t\xe9 r\xe9p\xe9t\xe9 entre parenth\xe8ses dans le champ du libell\xe9 infra, et inversement.\\n\\nEn synth\xe8se, ces donn\xe9es ne sont pas particuli\xe8rement propres: elles ont \xe9t\xe9 saisies manuellement par des utilisateurs vari\xe9s dans un syst\xe8me o\xf9 ils pouvaient saisir ce qu\'ils voulaient dans un champ texte libre. Un nettoyage va s\'imposer.\\n\\n<details>\\n\\n<summary>Cliquez ici pour un aper\xe7u des donn\xe9es</summary>\\n\\n| idVoie | uic8     | libGare          | libInfraVoie | libCommVoie |\\n| :----- | :------- | :--------------- | :----------- | :---------- |\\n| 1      | 87745000 | Bellegarde (Ain) | B (CUZ>GCO)  | B (CUZ>GCO) |\\n| 2      | 87745000 | Bellegarde (Ain) | B (GCO>CUZ)  | B (GCO>CUZ) |\\n| 3      | 87745000 | Bellegarde (Ain) | A(CUZ>GCO    | A (CUZ>GCO) |\\n| 4      | 87745000 | Bellegarde (Ain) | 1H           | 1           |\\n| 5      | 87745000 | Bellegarde (Ain) | G            | G           |\\n| 6      | 87745000 | Bellegarde (Ain) | E (GCO>CUZ)  | E (GCO>CUZ) |\\n| 7      | 87745000 | Bellegarde (Ain) |              | C (CUZ>GCO) |\\n| 8      | 87745000 | Bellegarde (Ain) | C (GCO>CUZ)  | C (GCO>CUZ) |\\n| 9      | 87745000 | Bellegarde (Ain) |              | A (GCO>CUZ) |\\n| 10     | 87745000 | Bellegarde (Ain) | E (CUZ>GCO)  | E (CUZ>GCO) |\\n| 11     | 87745000 | Bellegarde (Ain) | 2H           | 2           |\\n| 12     | 87584052 | Libourne         | 2(B)         | B(2)        |\\n| 13     | 87584052 | Libourne         | 1            | C(1)        |\\n| 14     | 87584052 | Libourne         | 2(B)         | B (2)       |\\n| 15     | 87584052 | Libourne         | 4(A)         | A(4)        |\\n| 16     | 87584052 | Libourne         | 3            | D(3)        |\\n| 17     | 87584052 | Libourne         | 3            | D(3)        |\\n| 18     | 87584052 | Libourne         | 3            | D(3)        |\\n| 19     | 87584052 | Libourne         | 1            | C(1)        |\\n| 20     | 87584052 | Libourne         | 1            | C(1)        |\\n| 21     | 87584052 | Libourne         | 4            | A           |\\n| 22     | 87584052 | Libourne         | 2            | B           |\\n| 23     | 87584052 | Libourne         | 2            | B           |\\n| 24     | 87741439 | L\xe9pin-le-Lac     | D            | B (Direct)  |\\n| 25     | 87741439 | L\xe9pin-le-Lac     | E            | A (Evi)     |\\n\\n</details>\\n\\n### Donn\xe9es de l\'environnement Hastus\\n\\nLa plupart des attributs qui nous int\xe9ressent ici sont en r\xe9alit\xe9 sp\xe9cifiques \xe0 la version SNCF d\'Hastus. Les attributs `Code R\xe9seau`, `Code Immuable` et `Code Chantier` ont \xe9t\xe9 cr\xe9\xe9s pour stocker les codes UIC de la gare \xe0 laquelle correspond chaque lieu. Le code UIC8 disponible dans les donn\xe9es du syst\xe8me maison correspond donc aux deux derniers caract\xe8res du code r\xe9seau, accol\xe9s au code immuable.\\n\\nLes attributs `Id Voie Agathe` et `Libell\xe9 Voie Agathe` donnent des indications sur le nom des voies, mais encore une fois, ne sont pas standardis\xe9s.\\n\\n<details>\\n\\n<summary>Cliquez ici pour un aper\xe7u des donn\xe9es</summary>\\n\\n| plcIdentifier | plcDescription                     | plcCodeReseau | plcCodeImmuable | plcCodeChantier | plcIdVoieAgathe | plcLibelleVoieAgathe |\\n| :------------ | :--------------------------------- | :------------ | :-------------- | :-------------- | :-------------- | :------------------- |\\n| LI1           | Libourne/BV - V1                   | 0087          | 584052          | BV              | 1               | V1                   |\\n| LI2           | Libourne/BV - V2                   | 0087          | 584052          | BV              | 2               | V2                   |\\n| LI3           | Libourne/BV - 3                    | 0087          | 584052          | BV              | 3               | 3                    |\\n| LI4           | Libourne/BV - 4                    | 0087          | 584052          | BV              | 4               | 4                    |\\n| LI5           | Libourne/BV - 5                    | 0087          | 584052          | BV              | 5               | 5                    |\\n| LPLd          | L\xe9pin-le-Lac-La Bauche/00 - UNIQUE | 0087          | 741439          | 00              | UNIQUE          | D                    |\\n| LPLe          | L\xe9pin-le-Lac-La Bauche/00 - E      | 0087          | 741439          | 00              | EVIT            | E                    |\\n| BGD1          | Bellegarde (Ain)/BV - V1           | 0087          | 745000          | BV              | V1              | V1                   |\\n| BGD1h         | Bellegarde (Ain)/BV - V1H          | 0087          | 745000          | BV              | V1H             | V1H                  |\\n| BGD2h         | Bellegarde (Ain)/BV - V2H          | 0087          | 745000          | BV              | V2H             | V2H                  |\\n| BGD5          | Bellegarde (Ain)/BV - V5           | 0087          | 745000          | BV              | V5              | V5                   |\\n| BGDa          | Bellegarde (Ain)/BV - A            | 0087          | 745000          | BV              | A               | A                    |\\n| BGDb          | Bellegarde (Ain)/BV - B            | 0087          | 745000          | BV              | B               | B                    |\\n| BGDe-         | Bellegarde (Ain)/BV - VE-          | 0087          | 745000          | BV              | VE-             | E                    |\\n| BGDfi         | Bellegarde (Ain)/BV - FI           | 0087          | 745000          | BV              | FI              | FI                   |\\n| BGDg          | Bellegarde (Ain)/BV - V2           | 0087          | 745000          | BV              | V2              | VG                   |\\n\\n</details>\\n\\n## Principe du traitement\\n\\n\xc9tant donn\xe9 qu\'une m\xeame voie peut exister sous plusieurs ID dans le syst\xe8me maison, mais pas dans Hastus, on va it\xe9rer sur les voies du syst\xe8me maison, et tenter de trouver pour chacune la meilleure voie Hastus possible. Plusieurs voies du syst\xe8me maison pourront donc \xeatre associ\xe9es \xe0 la m\xeame voie Hastus. Mais certaines voies Hastus pourraient n\'\xeatre associ\xe9es \xe0 aucune voie du syst\xe8me maison. Dans notre cas, les _cibles_ sont donc les voies du syst\xe8me maison et les _candidats_ sont les lieux Hastus.\\n\\n:::note\\n  `findBestMatchForTargetAmongCandidates`, comme son nom l\'indique, trouve une\\n  correspondance pour __une *cible*__ parmi __plusieurs *candidats*__ et n\'est\\n  pas appropri\xe9 pour les cas o\xf9 on souhaite des correspondances strictes _un\\n  pour un_ entre deux listes. Il faut alors utiliser d\'autres services, comme\\n  `matchTwoListsOfString`, ou utiliser `findBestMatchForTargetAmongCandidates`\\n  mais ajouter de la logique autour pour retirer les candidats de la liste \xe0\\n  mesure qu\'ils sont associ\xe9s aux cibles.\\n:::\\n\\nPour une _cible_ donn\xe9e, la liste de _candidats_ sera constitu\xe9e des lieux Hastus qui ont le m\xeame code UIC8 que la cible. Dans cette liste de candidat, on va alors essayer d\'en trouver un qui a le m\xeame _nom de voie_ que la cible. Mais comme on l\'a vu pr\xe9c\xe9demment, le _nom de voie_ n\'est pas standard, et dans beaucoup de cas, les noms de voies devront \xeatre nettoy\xe9s si on veut qu\'ils correspondent entre eux.\\n\\nC\'est ici que le m\xe9canisme it\xe9ratif de `findBestMatchForTargetAmongCandidates` sera utile.\\n\\n## Concepts de `findBestMatchForTargetAmongCandidates`\\n\\nCi-dessous, un r\xe9sum\xe9 du README de `findBestMatchForTargetAmongCandidates` (auquel vous devriez vous r\xe9f\xe9rer pour plus de d\xe9tails) avec la traduction des concepts pour notre cas pr\xe9cis.\\n\\n### Principe de fonctionnement\\n\\nOn essaie en plusieurs it\xe9rations de trouver la meilleure correspondance pour une _cible_ parmi plusieurs _candidats_.\\n\\n\xc0 chaque it\xe9ration, on passe par deux phases:\\n\\n1. R\xe9duire la liste de candiats\\n2. Calculer une _distance_ entre la _cible_ et chaque _candidat_, et d\xe9clarer un _bestMatch_ si les _crit\xe8res_ sont atteints\\n\\nCes principes donnent beaucoup de flexibilit\xe9 et permettent d\'ajuster rapidement et facilement les crit\xe8res afin d\'optimiser la performance et la qualit\xe9 des correspondances. Par exemple:\\n\\n- on d\xe9fini une premi\xe8re it\xe9ration tr\xe8s stricte, qui cible une liste r\xe9duite de candidats, avec un calcul de distance simple pour abattre rapidement une grosse partie du travail\\n- dans les it\xe9rations suivantes, on peut se permettre de cibler plus de candidats et d\'avoir des crit\xe8res plus complexes, car on sait qu\'elle ne seront ex\xe9cut\xe9es que sur les quelques cibles restantes\\n- si \xe7a n\'a toujours pas suffi, on peut faire des tentatives carr\xe9ment loufoques dans les derni\xe8res it\xe9rations, quitte \xe0 traiter avec un grain de sel les r\xe9sultats obtenus dans celles-ci\\n\\n### `target` et `candidates`\\n\\nLa `target` ou _cible_ est l\'objet pour lequel on recherche une correspondance parmi plusieurs `candidates` ou _candidats_.\\n\\nDans notre cas, la _cible_ sera une voie du syst\xe8me maison et les _candidats_ seront les lieux Hastus.\\n\\n### Phase 1 : R\xe9duire la liste de candidats\\n\\nLes options pour cette phase sont d\xe9finies sous la cl\xe9 `candidatesFilteringConfig` de la configuration globale.\\nSi cette cl\xe9 n\'est pas d\xe9finie, tous les candidats sont utilis\xe9s. Si la clef est d\xe9finie, les candidats sont filtr\xe9s dans deux sous-phases.\\n\\n#### Phase 1A: filterPredicate\\n\\nCette phase est utile pour \xe9liminer des candidats sur la base de crit\xe8res fixes, qui ne varient pas en fonction de la cible.\\n\\nElle n\'est pas utilis\xe9e dans notre cas car nos filtres fixes sont les m\xeames pour toutes les it\xe9rations, donc nous les appliquons une fois pour toute dans le script avant m\xeame de rentrer dans `findBestMatchForTargetAmongCandidates`\\n\\n#### Phase 1B: regrouper les candidats et conserver le groupe qui correspond \xe0 une clef calcul\xe9e sur la cible\\n\\nCette phase permet de ne conserver que les candidats qui ont une caract\xe9ristique commune avec la cible.\\n\\nD\'abord, on regroupe tous les candidats sur la base de cette caract\xe9ristique. Ensuite, on calcule (si n\xe9cessaire) la valeur de cette caract\xe9ristique pour la cible, et on ne conserve que les candidats qui ont la m\xeame valeur que la cible.\\n\\nDans notre cas, la caract\xe9ristique commune qui nous int\xe9resse est le code UIC8. On va regrouper les lieux Hastus par code UIC8 et ne consid\xe9rer que ceux qui ont le m\xeame que la voie maison.\\n\\n### Phase 2 : trouver le meilleur candidat parmi ceux qui restent\\n\\nLes options pour cette phase sont d\xe9finies sous la cl\xe9 `getBestMatchConfig` de la configuration globale. Plusieurs options de configuration existent, mais les deux plus importantes sont `distanceFunction` et `maxDistance`\\n\\n`distanceFunction` est une fonction qui doit calculer une _distance_ entre la cible et le candidat. Pour un candidat qui correspond parfaitement \xe0 la cible, `distanceFunction` devrait renvoyer `0`. Moins le candidat correspond \xe0 la cible, plus la valeur renvoy\xe9e par `distanceFunction` devrait \xeatre grande.\\n\\nSi aucun des candidats n\'a une valeur de `0`, alors c\'est le candidat qui a la plus petite valeur qui est consid\xe9r\xe9 comme la meilleure correspondance, \xe0 condition que cette valeur soit inf\xe9rieure \xe0 la valeur d\xe9finie dans `maxDistance`\\n\\nDans notre cas, on ne va pas utiliser ce m\xe9canisme \xe0 son plein potentiel. Notre `distanceFunction` va simplement comparer les libell\xe9s de voie, apr\xe8s les avoir plus ou moins nettoy\xe9s. Si elle trouve une correspondance exacte entre libell\xe9s de voies nettoy\xe9s, elle va renvoyer `0`. Sinon, elle va renvoyer +infini, et il faudra passer au candidat suivant, puis \xe0 l\'it\xe9ration suivante le cas \xe9ch\xe9ant.\\n\\n## \xc9tapes de nettoyage\\n\\n\xc0 chaque it\xe9ration, on fait les 4 comparaisons possibles:\\n\\n- Libell\xe9 Infra vs Id Voie\\n- Libell\xe9 Commercial vs Id voie\\n- Libell\xe9 Infra vs Libell\xe9 Voie\\n- Libell\xe9 Commercial vs Libell\xe9 Voie\\n\\nOn consid\xe8re qu\'un lieu Hastus correspond \xe0 la voie maison d\xe8s que les valeurs sont les m\xeames pour une des comparaison.\\n\\n\xc0 chaque fois, on applique des \\"nettoyages\\" aux valeurs de la cible et des candidats avant de les comparer.\\n\\n\xc0 chaque it\xe9ration, on ajoute des \\"nettoyages\\" en plus de ceux faits aux it\xe9rations pr\xe9c\xe9dentes. Par exemple:\\n\\n1. mettre tout en minuscules\\n2. retirer les \\"V\\" ou \\"v\\" au d\xe9but des libell\xe9s\\n3. retirer tout texte entre parenth\xe8ses\\n4. transformer UNIQUE en U, BIS en B, TER en T\\n5. retirer les espaces au milieu des libell\xe9s\\n\\n## Mise en oeuvre\\n\\nCi-dessous, un aper\xe7u comment\xe9 de la fonction qui utilise `findBestMatchForTargetAmongCandidates` dans le script.\\n\\n```javascript title=\\"getBestMatchResultByExternalTrack.js\\"\\n/** Les utilitaires ci-dessous seront bri\xe8vement d\xe9crits quand ils seront\\n * utilis\xe9s dans le code */\\nconst findBestMatch = require(\'@bimo/core-utils-find-best-match-for-target-among-candidates\');\\nconst {\\n  cleanStringUsingRegexAndReplacePairs,\\n} = require(\'@bimo/core-utils-string\');\\nconst matchTwoListsOfStrings = require(\'@bimo/core-utils-match-two-lists-of-strings\');\\nconst { countBy } = require(\'lodash\');\\n\\n/** Cette fonction est appell\xe9e par le script, qui s\'est charg\xe9 par ailleurs\\n * - de charger les voies maisons et d\'en faire un array d\'objets\\n *   (externalTracks)\\n * - de charger et pr\xe9-filtrer le jeu de lieux Hastus (placesCollection)\\n */\\nfunction getBestMatchResultByExternalTrack(\\n  externalTracks,\\n  placesCollection,\\n  logger\\n) {\\n  /** Dans notre cas, on va filtrer les lieux de la m\xeame mani\xe8re pour toutes les\\n   * it\xe9rations. On d\xe9finit donc une seule fois candidatesFilteringConfig\\n   * Mais gardez en t\xeate qu\'on peut parfaitement le faire varier \xe0 chaque\\n   * it\xe9ration quand c\'est utile.\\n   */\\n  const candidatesFilteringConfig = {\\n    /** La target est la voie maison, qui poss\xe8de directement une cl\xe9 \'uic8\' */\\n    getKeyFromTargetConfig: \'uic8\',\\n    /** Il n\'y a pas directement de cl\xe9 \xe9quivalent sur les lieux Hastus,\\n     * on la fabrique \xe0 la vol\xe9e avec la fonction ci-dessous */\\n    groupCandidatesByConfig: (place) =>\\n      `${place.plcCodeReseau.substr(-2)}${place.plcCodeImmuable}`,\\n  };\\n\\n  /** La \\"distanceFunction\\" varie \xe0 chaque it\xe9ration, mais elle a toujours la\\n   * m\xeame forme. On va donc cr\xe9er une \\"distanceFunctionFactory\\": une fonction\\n   * qui retourne une fonction.\\n   * \xc0 chaque it\xe9ration, on va appeler la factory en lui passant des\\n   * regexAndReplacePairs plus ou moins complexes pour transformer les strings.\\n   * On obtiendra alors une \\"distanceFunction\\" classique qui transforme les\\n   * strings, puis les compare, et retourne 0 s\'il y a un match, +infini sinon.\\n   * */\\n  const distanceFunctionFactory =\\n    (regexAndReplacePairs) => (externalTrackPlace, hastusPlace) => {\\n      /** Pour simplifier les manipulations, on regroupe les strings qui nous int\xe9ressent */\\n      const rawExternalStrings = [\\n        externalTrackPlace.libInfraVoie,\\n        externalTrackPlace.libCommVoie,\\n      ];\\n      const rawHastusStrings = [\\n        hastusPlace.plcIdVoieAgathe,\\n        hastusPlace.plcLibelleVoieAgathe,\\n      ];\\n\\n      /** cleanStringUsingRegexAndReplacePairs applique successivement des\\n       * expressions r\xe9guli\xe8res \xe0 une string pour la nettoyer */\\n      const cleanExternalStrings = rawExternalStrings.map((s) =>\\n        cleanStringUsingRegexAndReplacePairs(\\n          s,\\n          regexAndReplacePairs\\n        ).toLowerCase()\\n      );\\n      const cleanHastusStrings = rawHastusStrings.map((s) =>\\n        cleanStringUsingRegexAndReplacePairs(\\n          s,\\n          regexAndReplacePairs\\n        ).toLowerCase()\\n      );\\n\\n      /** En l\'utilisant avec l\'option { returnOnFirstMatch: true }\\n       * matchTwoListsOfStrings permet de savoir rapidement s\'il y a une\\n       * correspondance exacte entre n\'importe quelles 2 strings de deux\\n       * listes  */\\n      const { matched } = matchTwoListsOfStrings(\\n        [cleanExternalStrings, cleanHastusStrings],\\n        { returnOnFirstMatch: true }\\n      );\\n\\n      return matched.length === 0 ? Number.POSITIVE_INFINITY : 0;\\n    };\\n\\n  /**On stockera les r\xe9sultats dans cette variable */\\n  const bestMatchResultByExternalTrack = new Map();\\n\\n  /** Les regexAndReplacePairs ci-dessous vont permettre de nettoyer les\\n   * strings. Si besoin de plus de d\xe9tails sur le fonctionnement des\\n   * regex, n\'h\xe9sitez pas \xe0 laisser un commentaire sous cet article */\\n  const removeVRegexAndReplacePair = [\'/^[vV](.+)$/\', \'$1\'];\\n  const removeParenthesisRegexAndReplacePair = [\\n    \'/(\\\\\\\\w+).*(\\\\\\\\(.+\\\\\\\\))/gim\',\\n    \'$1\',\\n  ];\\n  const transformUniqueIntoU = [\'/^UNIQUE$/i\', \'U\'];\\n  const transformBisIntoB = [\'/BIS/i\', \'B\'];\\n  const transformTerIntoT = [\'/TER/i\', \'T\'];\\n  const removeSpaces = [\'/ /g\', \'\'];\\n\\n  externalTracks.forEach((externalTrack) => {\\n    /** Noter que findBestMatch... accepte les candidates sous la forme d\'un\\n     * array ou d\'une collection. La collection est pr\xe9f\xe9rable car permet de\\n     * profiter du cache pour am\xe9liorer la performance */\\n    const bestMatchResult = findBestMatch(\\n      { target: externalTrack, candidates: placesCollection },\\n      {\\n        iterationConfigs: [\\n          {\\n            iterationName: \'1 = tout mettre en minuscule\',\\n            candidatesFilteringConfig /** Voir ligne 25 */,\\n            getBestMatchConfig: {\\n              detailedResults: true,\\n              distanceFunction: distanceFunctionFactory([\\n                /**Aucun nettoyage particulier pour cette it\xe9ration */\\n              ]),\\n              maxDistance: 1,\\n            },\\n          },\\n          {\\n            iterationName:\\n              \'2 = 1 + retrait des \\"V\\" ou \\"v\\" au d\xe9but des noms de voies\',\\n            candidatesFilteringConfig,\\n            getBestMatchConfig: {\\n              detailedResults: true,\\n              distanceFunction: distanceFunctionFactory([\\n                removeVRegexAndReplacePair,\\n              ]),\\n              maxDistance: 1,\\n            },\\n          },\\n          {\\n            iterationName: \'3 = 2 + retrait du texte entre parenth\xe8ses\',\\n            candidatesFilteringConfig,\\n            getBestMatchConfig: {\\n              detailedResults: true,\\n              distanceFunction: distanceFunctionFactory([\\n                removeVRegexAndReplacePair,\\n                removeParenthesisRegexAndReplacePair,\\n              ]),\\n              maxDistance: 1,\\n            },\\n          },\\n          {\\n            iterationName: \'4 = 3 + transfo UNIQUE > U, BIS > B, TER > T\',\\n            candidatesFilteringConfig,\\n            getBestMatchConfig: {\\n              detailedResults: true,\\n              distanceFunction: distanceFunctionFactory([\\n                removeVRegexAndReplacePair,\\n                removeParenthesisRegexAndReplacePair,\\n                transformUniqueIntoU,\\n                transformBisIntoB,\\n                transformTerIntoT,\\n              ]),\\n              maxDistance: 1,\\n            },\\n          },\\n          {\\n            iterationName: \'5 = 4 + retrait des espaces\',\\n            candidatesFilteringConfig,\\n            getBestMatchConfig: {\\n              detailedResults: true,\\n              distanceFunction: distanceFunctionFactory([\\n                removeVRegexAndReplacePair,\\n                removeParenthesisRegexAndReplacePair,\\n                transformUniqueIntoU,\\n                transformBisIntoB,\\n                transformTerIntoT,\\n                removeSpaces,\\n              ]),\\n              maxDistance: 1,\\n            },\\n          },\\n        ],\\n      }\\n    );\\n    bestMatchResultByExternalTrack.set(externalTrack, bestMatchResult);\\n  });\\n\\n  /** on laisse ce petit exemple de rapport minimaliste pour montrer que les\\n   * r\xe9sultats incluent des infos sur l\'it\xe9ration qui a produit le match */\\n  const numberOfMatchesByIteration = countBy(\\n    Array.from(bestMatchResultByExternalTrack.values()),\\n    \'indexOfIterationThatMatched\'\\n  );\\n  logger.info(JSON.stringify(numberOfMatchesByIteration));\\n\\n  return bestMatchResultByExternalTrack;\\n}\\n\\nmodule.exports = getBestMatchResultByExternalTrack;\\n```\\n\\n## Conclusion\\n\\nM\xeame si cet exemple ne tire pas profit de toute la puissance de `findBestMatchForTargetAmongCandidates` il illustre bien _l\'expressivit\xe9_ rendue possible gr\xe2ce au syst\xe8me des it\xe9rations.\\n\\nEn quelques dizaines de lignes de code, on met en place une structure qui permet ensuite de s\'amuser facilement avec les donn\xe9es, en ajoutant simplement de nouvelles it\xe9rations, mais en conservant beaucoup de puissance et de flexibilit\xe9."},{"id":"creation-du-service-get-bbox-for-place","metadata":{"permalink":"/examples/creation-du-service-get-bbox-for-place","source":"@site/examples/creation-du-service-get-bbox-for-place.mdx","title":"Cr\xe9er un nouveau service Bimo","description":"Dans Extraire automatiquement des images de plans de voies \xe0 partir de la cartographie Hastus, on a eu besoin de cr\xe9er un nouveau service. Nous allons voir comment cela se passe dans cet article.","date":"2022-11-28T00:00:00.000Z","tags":[{"inline":true,"label":"cartographie","permalink":"/examples/tags/cartographie"},{"inline":true,"label":"lieux","permalink":"/examples/tags/lieux"},{"inline":true,"label":"getBboxForPlace","permalink":"/examples/tags/get-bbox-for-place"}],"hasTruncateMarker":false,"authors":[{"name":"Ga\xebl Ham\xe9on","title":"Cr\xe9ateur de Bimo","url":"https://github.com/gaelhameon","imageURL":"https://github.com/gaelhameon.png","key":"gael"}],"frontMatter":{"slug":"creation-du-service-get-bbox-for-place","title":"Cr\xe9er un nouveau service Bimo","lead":"Un exemple du processus de cr\xe9ation d\'un nouveau service Bimo.","date":"2022-11-28","authors":["gael"],"tags":["cartographie","lieux","getBboxForPlace"],"hide_blog_post_date":true},"unlisted":false,"prevItem":{"title":"R\xe9concilier les lieux de deux syst\xe8mes diff\xe9rents","permalink":"/examples/r\xe9concilier-les-lieux-de-deux-syst\xe8mes-diff\xe9rents-avec-find-best-match-for-target-among-candidates"},"nextItem":{"title":"Extraire automatiquement des images de plans de voies \xe0 partir de la cartographie Hastus","permalink":"/examples/extraire-automatiquement-des-images-de-plans-de-voies-\xe0-partir-de-la-cartographie-hastus"}},"content":"Dans [Extraire automatiquement des images de plans de voies \xe0 partir de la cartographie Hastus](./extraire-automatiquement-des-images-de-plans-de-voies-\xe0-partir-de-la-cartographie-hastus/#automatisation), on a eu besoin de cr\xe9er un nouveau service. Nous allons voir comment cela se passe dans cet article.\\n\\n## Initialiser le service\\n\\nNous sommes petit \xe0 petit en train de migrer vers l\'outil [nx](https://nx.dev/) pour g\xe9rer le repo bimo. Id\xe9alement, nous utiliserions donc un [g\xe9n\xe9rateur](https://nx.dev/recipes/generators#generators) pour initialiser un nouveau service.\\n\\nMais pour le moment, nous allons simplement faire un copier coller d\'un service existant.\\n\\nEnsuite, afin d\'avoir du code bien document\xe9 et test\xe9, on commence toujours par r\xe9diger le README et les tests.\\n\\n## R\xe9diger le README\\n\\nOn veut donc un service qui re\xe7oit un lieu, des param\xe8tres, et retourne une \\"Bounding Box\\". Mais qu\'est-ce qu\'une bounding box ? Pour le cas d\'usage qui nous pousse \xe0 cr\xe9er ce service, on va vouloir passer les coordonn\xe9es sous forme de string `xmin,ymin,xmax,ymax` \xe0 une commande mapshaper, mais ce serait dommage de s\'enfermer dans ce format.\\n\\nOn va donc cr\xe9er une nouvelle classe, qui nous permettra facilement de cr\xe9er des bbox \xe0 partir de plusieurs sources ou formats de donn\xe9es, puis de les exprimer sous plusieurs formes, notamment sous forme de string mapshaper. On ne va pas s\'y attarder ici, mais le code est disponible ci-dessous:\\n\\n```javascript title=\\"BoundingBox.js\\"\\nconst {\\n  getAllChildClasses,\\n  serializeThis,\\n  parseThis,\\n} = require(\'@bimo/core-utils-serialization\');\\nconst getAndValidatePropFromProps = require(\'@bimo/core-utils-get-and-validate-prop-from-props\');\\nconst Item = require(\'@bimo/core-utils-item\');\\nconst { pick } = require(\'lodash\');\\n\\nconst childClasses = [];\\n\\nclass BoundingBox extends Item {\\n  constructor(rawProps) {\\n    const props = Array.isArray(rawProps)\\n      ? {\\n          xMin: rawProps[0],\\n          yMin: rawProps[1],\\n          xMax: rawProps[2],\\n          yMax: rawProps[3],\\n        }\\n      : rawProps;\\n    super(props, \'BoundingBox\');\\n    this.activeCoordinatesSystemName = getAndValidatePropFromProps(\\n      \'activeCoordinatesSystemName\',\\n      rawProps,\\n      \'string\',\\n      \'default\'\\n    );\\n    this.coordinatesBySystemName = getAndValidatePropFromProps(\\n      \'coordinatesBySystemName\',\\n      rawProps,\\n      Object,\\n      {}\\n    );\\n    if (Object.keys(this.coordinatesBySystemName).length === 0) {\\n      this.coordinatesBySystemName.default = pick(props, [\\n        \'xMin\',\\n        \'xMax\',\\n        \'yMin\',\\n        \'yMax\',\\n      ]);\\n    }\\n  }\\n\\n  get xMin() {\\n    return this.coordinatesBySystemName[this.activeCoordinatesSystemName].xMin;\\n  }\\n\\n  get yMin() {\\n    return this.coordinatesBySystemName[this.activeCoordinatesSystemName].yMin;\\n  }\\n\\n  get xMax() {\\n    return this.coordinatesBySystemName[this.activeCoordinatesSystemName].xMax;\\n  }\\n\\n  get yMax() {\\n    return this.coordinatesBySystemName[this.activeCoordinatesSystemName].yMax;\\n  }\\n\\n  get dX() {\\n    return this.xMax - this.xMin;\\n  }\\n\\n  get dY() {\\n    return this.yMax - this.yMin;\\n  }\\n\\n  get mapshaperStyleString() {\\n    return `${this.xMin},${this.yMin},${this.xMax},${this.yMax}`;\\n  }\\n\\n  get shortLoggingOutput() {\\n    return `bbox: ${this.mapshaperStyleString}`;\\n  }\\n\\n  get mediumLoggingOutput() {\\n    return `${this.shortLoggingOutput} dX: ${this.dX}  dY: ${this.dY}`;\\n  }\\n\\n  setActiveCoordinatesSystemName(coordinatesSystemName) {\\n    this.activeCoordinatesSystemName = coordinatesSystemName;\\n  }\\n}\\n\\nBoundingBox.allChildClasses = getAllChildClasses(childClasses);\\nBoundingBox.prototype.serializeModel = serializeThis;\\nBoundingBox.parseModel = parseThis;\\n\\nmodule.exports = BoundingBox;\\n```\\n\\nPar ailleurs, toujours pour notre cas d\'usage initial, on va vouloir \xe9largir un peu la bounding box autour des coordonn\xe9es des lieux. Il faudrait donc que le service soit param\xe9trable et qu\'on puisse sp\xe9cifier les marges \xe0 prendre autour des lieux.\\n\\nOn a donc maintenant une d\xe9finition claire des objets manipul\xe9s par notre service: il re\xe7oit un lieu et des param\xe8tres, et retourne une \\"Bounding Box\\".\\n\\nOn va d\xe9crire ceci dans le README, et donner des exemples de code qui utiliseraient ce service:\\n\\n```markdown title=\\"README.md\\" collapsedNumberOfLines=10\\n# `@bimo/core-services-get-bbox-for-place`\\n\\nReturns a bounding box for a place, according to various parameters.\\n\\nMost importantly, if the place is a reference place, this will look at the coordinates of all places associated to this place, and return a bounding box that includes all these places, with a default padding of 100 units unless otherwise specified.\\n\\n## Usage\\n```\\n\\n(La partie ci-dessous est incluse dans le README mais on la s\xe9pare ici pour qu\'elle soit plus lisible)\\n\\n```javascript title=\\"README.md\\"\\nconst { PlacesCollection } = require(\'@bimo/core-entities\');\\n\\nconst placesCollection = new PlacesCollection({\\n  items: [\\n    { plcIdentifier: \'A\' },\\n    {\\n      plcIdentifier: \'A1\',\\n      plcReferencePlace: \'A\',\\n      locaLocMethod: \'5\',\\n      locaXCoord: \'20\',\\n      locaYCoord: \'20\',\\n    },\\n    {\\n      plcIdentifier: \'A2\',\\n      plcReferencePlace: \'A\',\\n      locaLocMethod: \'5\',\\n      locaXCoord: \'0\',\\n      locaYCoord: \'0\',\\n    },\\n  ],\\n});\\n\\nconst getBboxForPlace = require(\'@bimo/core-services-get-bbox-for-place\');\\n\\nconst placeA = placesCollection.getByBusinessId(\'A\');\\nconst bBox1 = getBboxForPlace(placeA, { padding: 10 }, { placesCollection });\\nconsole.log(typeof bBox1);\\n// BoundingBox\\n\\nconsole.log(bBox1.mapshaperStyleString);\\n// \\"-10,-10,30,30\\"\\n\\nconst bBox2 = getBboxForPlace(\\n  placeA,\\n  {\\n    xPadding: 10,\\n    yMinPadding: 5,\\n    yMaxPadding: 0,\\n  },\\n  { placesCollection }\\n);\\n\\nconst { xMin, yMin, xMax, yMax } = bBox2;\\nconsole.log({ xMin, yMin, xMax, yMax });\\n// { xMin: -10, yMin: -5, xMax: 30, yMax: 20 }\\n```\\n\\nVoil\xe0, on a maintenant des exemples concrets de comment on voudrait que ce service soit utilis\xe9. On va partir de \xe7a pour r\xe9diger des tests.\\n\\n## R\xe9diger les tests\\n\\nD\'abord, on pr\xe9pare des donn\xe9es de test, dans un fichier \\"prepareData.js\\":\\n\\n```javascript title=\\"prepareData.js\\"\\nconst { PlacesCollection } = require(\'@bimo/core-entities\');\\nconst deepFreeze = require(\'deep-freeze-es6\');\\n\\nmodule.exports = () => {\\n  let placesCollection = new PlacesCollection({\\n    items: [\\n      { plcIdentifier: \'A\' },\\n      { plcIdentifier: \'B\' },\\n      {\\n        plcIdentifier: \'A1\',\\n        plcReferencePlace: \'A\',\\n        locaLocMethod: \'5\',\\n        locaXCoord: \'20\',\\n        locaYCoord: \'20\',\\n      },\\n      {\\n        plcIdentifier: \'A2\',\\n        plcReferencePlace: \'A\',\\n        locaLocMethod: \'5\',\\n        locaXCoord: \'0\',\\n        locaYCoord: \'0\',\\n      },\\n      {\\n        plcIdentifier: \'B1\',\\n        plcReferencePlace: \'B\',\\n        locaLocMethod: \'5\',\\n        locaXCoord: \'-10\',\\n        locaYCoord: \'0\',\\n      },\\n      {\\n        plcIdentifier: \'B2\',\\n        plcReferencePlace: \'B\',\\n        locaLocMethod: \'5\',\\n        locaXCoord: \'0\',\\n        locaYCoord: \'-10\',\\n      },\\n      {\\n        plcIdentifier: \'B3\',\\n        plcReferencePlace: \'B\',\\n        locaLocMethod: \'5\',\\n        locaXCoord: \'10\',\\n        locaYCoord: \'0\',\\n      },\\n      {\\n        plcIdentifier: \'B4\',\\n        plcReferencePlace: \'B\',\\n        locaLocMethod: \'5\',\\n        locaXCoord: \'0\',\\n        locaYCoord: \'10\',\\n      },\\n    ],\\n  });\\n  // Force calculation of cached values\\n  const dummy = placesCollection.placesByReferencePlace;\\n  placesCollection = deepFreeze(placesCollection);\\n\\n  return { placesCollection };\\n};\\n```\\n\\nOn fabrique simplement un jeu de lieux, avec des donn\xe9es fictives. On calcule le `placesByReferencePlace` puis on \\"freeze\\" l\'objet. C\'est une bonne habitude \xe0 prendre pour les tests des services qui n\'ont pas vocation \xe0 modifier des objets: si jamais notre code avait des effets de bord ind\xe9sirables qui essaieraient de modifier l\'objet, le test \xe9chouerait.\\n\\nOn va ensuite utiliser ces donn\xe9es dans le fichier de test:\\n\\n```javascript title=\\"getBboxForPlace.spec.js\\"\\nconst { expect } = require(\'chai\');\\nconst logger = require(\'@bimo/core-utils-logging\').getStupidLogger(true);\\n\\nconst getBboxForPlace = require(\'../src/getBboxForPlace\');\\n\\nconst { placesCollection } = require(\'./prepareData\')();\\n\\nconst serviceContext = { logger };\\n\\ndescribe(\'getBboxForPlace\', () => {\\n  const testParamsByTestName = {\\n    \'default config on place A\': {\\n      placeId: \'A\', // pour rappel, le lieu A a deux lieux voies, un \xe0 [0,0] et un \xe0 [20, 20]\\n      config: {},\\n      expectedResult: `-100,-100,120,120`, // la config par d\xe9faut ajouter des marges de 100 unit\xe9s dans chaque direction\\n    },\\n    \'default config on place B\': {\\n      placeId: \'B\', // pour rappel, le lieu B a quatre lieux voies, \xe0 [-10,0], [10,0], [0,-10], [0,10]\\n      config: {},\\n      expectedResult: `-110,-110,110,110`,\\n    },\\n    \'custom padding on place A\': {\\n      placeId: \'A\',\\n      config: { padding: 5 },\\n      expectedResult: `-5,-5,25,25`,\\n    },\\n    \'custom padding only on X on place A\': {\\n      // so the y padding will remain the default = 100\\n      placeId: \'A\',\\n      config: { xPadding: 5 },\\n      expectedResult: `-5,-100,25,120`,\\n    },\\n  };\\n  Object.entries(testParamsByTestName).forEach(([testName, testParams]) => {\\n    it(`works with ${testName}`, () => {\\n      const { placeId, config, expectedResult } = testParams;\\n      const place = placesCollection.getByBusinessId(placeId);\\n      const bBox = getBboxForPlace(place, config, serviceContext);\\n      expect(bBox.mapshaperStyleString).to.equal(expectedResult);\\n    });\\n  });\\n});\\n```\\n\\nOn utilise des tests param\xe9trables, ce qui permet d\'ajouter facilement des cas de tests pour de nouvelles options de configuration qui pourraient appara\xeetre dans le futur.\\n\\n\xc0 ce stade, si on lance les tests, tout devrait \xe9chouer, et c\'est normal !\\n\\n## Coder le service\\n\\nOn va maintenant pouvoir coder la fonction et relancer les tests au fur et \xe0 mesure, en ajoutant les options de configuration n\xe9cessaires etc. Ici pour abr\xe9ger on va directement passer \xe0 la version finale. Ci-dessous, une version largement comment\xe9e directement dans le code.\\n\\n```javascript title=\\"getBboxForPlace.js\\"\\nconst { BoundingBox } = require(\'@bimo/core-entities\');\\nconst retrievePlace = require(\'@bimo/core-services-retrieve-place\');\\n\\nfunction getBboxForPlace(placeLike, config = {}, context = {}) {\\n  const {\\n    padding = 100,\\n    xPadding = padding,\\n    yPadding = padding,\\n    xMinPadding = xPadding,\\n    xMaxPadding = xPadding,\\n    yMinPadding = yPadding,\\n    yMaxPadding = yPadding,\\n  } = config;\\n  /**\\n   * Par d\xe9faut, on ajoute des marges de 100 de tous les c\xf4t\xe9s, ou alors la\\n   * marge sp\xe9cifi\xe9e par l\'utiliateur de tous les c\xf4t\xe9s, mais on laisse\\n   * aussi l\'utilisateur sp\xe9cifier des marges diff\xe9rentes en X et Y, voire\\n   * m\xeame \xe0 droite, \xe0 gauche, en haut et en bas.\\n   */\\n\\n  const sourcePlace = retrievePlace(\\n    placeLike,\\n    context.placesCollection,\\n    context\\n  );\\n  /** Il arrive souvent qu\'on manipule des objets qui ressemblent \xe0 des lieux,\\n   * mais n\'en sont pas vraiment. Par exemple, quand on manipule un voyage, sa\\n   * propri\xe9t\xe9 Trip.trpPlaceStart contient seulement un ID de lieu, mais dans\\n   * l\'esprit de tout le monde, c\'est un lieu. Pour \xe9viter de devoir recoder\\n   * chaque fois le travail d\'aller chercher un lieu dans un jeu de lieu sur la\\n   * base de son ID, on utilise le service \\"retrievePlace\\". Si on lui passe\\n   * quelque chose qui est d\xe9j\xe0 un lieu en bonne et due forme, il ne fait rien.\\n   * Si on lui passe autre chose, il va essayer de l\'interpr\xe9ter, et de\\n   * r\xe9cup\xe9rer un vrai lieu \xe0 partir de cette autre chose et du jeu de lieux.\\n   */\\n\\n  let xMin = Number.POSITIVE_INFINITY;\\n  let yMin = Number.POSITIVE_INFINITY;\\n  let xMax = Number.NEGATIVE_INFINITY;\\n  let yMax = Number.NEGATIVE_INFINITY;\\n\\n  const allPlaces = [sourcePlace, ...sourcePlace.childrenPlaces];\\n  /** Pour le moment, la seule \\"intelligence\\" de notre service est ici: on sait\\n   * que pour un lieu donn\xe9, on va vouloir contr\xf4ler les coordonn\xe9es de ce lieu\\n   * et de tous les lieux qui lui sont rattach\xe9s. \xc9ventuellement, on pourrait\\n   * faire \xe9voluer ceci pour ne le faire que si certaines options sont\\n   * pr\xe9cis\xe9es dans la config.\\n   */\\n\\n  allPlaces.forEach((place) => {\\n    if (place.isLocated) {\\n      const x = parseFloat(place.locaXCoord);\\n      const y = parseFloat(place.locaYCoord);\\n      if (x < xMin) xMin = x;\\n      if (x > xMax) xMax = x;\\n      if (y < yMin) yMin = y;\\n      if (y > yMax) yMax = y;\\n    }\\n  });\\n\\n  if (xMin === Number.POSITIVE_INFINITY)\\n    throw new Error(`Could not compute BBox for ${sourcePlace.slo}`);\\n  // Si xMin n\'a toujours pas boug\xe9, il y a eu un probl\xe8me ...\\n\\n  return new BoundingBox({\\n    xMin: xMin - xMinPadding,\\n    yMin: yMin - yMinPadding,\\n    xMax: xMax + xMaxPadding,\\n    yMax: yMax + yMaxPadding,\\n  });\\n  // Il y a un deuxi\xe8me petit bout de valeur ajout\xe9e \xe0 notre service ici, qui g\xe8re les marges.\\n}\\n\\nmodule.exports = getBboxForPlace;\\n```\\n\\nOn peut maintenant v\xe9rifier que \xe7a fonctionne pour tous nos tests:\\n\\n```txt file=consoleOutput\\n  getBboxForPlace\\n    \u2714 works with default config on place A\\n    \u2714 works with default config on place B\\n    \u2714 works with custom padding on place A\\n    \u2714 works with custom padding only on X on place A\\n```\\n\\nEt c\'est bien le cas !\\n\\n## Conclusion\\n\\nLe temps passer \xe0 r\xe9diger le README et les tests a probablement \xe9t\xe9 plus long que le temps pass\xe9 \xe0 r\xe9diger le code du service lui-m\xeame. Et \xe0 premi\xe8re vue \xe7a peut sembler \xeatre une perte de temps. Mais si on n\'avait pas fait comme \xe7a, on aurait fait comment ?\\n\\nOn aurait \xe9crit la fonction directement dans le script qui en avait besoin. Pour la tester, il aurait fallu lancer \xe0 chaque fois le script complet, qui allait charger \xe0 chaque fois un jeu de lieux complet (donc prendre du temps) ... \xe0 moins qu\'on prenne le temps de pr\xe9parer un jeu de lieux partiel pour tester le script ?\\n\\nOn aurait regard\xe9 le r\xe9sultat global du script - les images des gares - et si on avait vu qu\'elles ne correspondaient pas \xe0 ce qu\'on souhaitait, on aurait d\xe9bugg\xe9: est-ce que le probl\xe8me vient du calcul de la bBox ? Ou d\'un bug dans la commande mapshaper ? Ou simplement de donn\xe9es qui sont fausses ? On aurait ajout\xe9 des \\"console.log\\" un peu partout dans le script ...\\n\\nBref, ne serait-ce que pour le d\xe9veloppement de ce script, au final, on n\'aurait pas n\xe9cessairement pass\xe9 moins de temps si on n\'avait pas pris la peine de faire un service s\xe9par\xe9 avec des tests s\xe9par\xe9s.\\n\\nMais en plus, maintenant:\\n\\n- si on a besoin de calculer une bBox pour un autre script ou un autre besoin, on a d\xe9j\xe0 un service sp\xe9cifique qu\'on peut importer individuellement n\'importe o\xf9\\n- si on veut faire \xe9voluer ce service pour y ajouter des fonctionnalit\xe9s:\\n  - on a d\xe9j\xe0 toute la structure pour ajouter des cas de tests correspondants aux nouvelles fonctionnalit\xe9s\\n  - mais surtout: on n\'a pas peur de casser les fonctionnalit\xe9s existantes, puisqu\'on a des tests pour celles-ci. On peut donc m\xeame se lancer dans une r\xe9\xe9criture compl\xe8te du service si on le souhaite: tant qu\'il passe toujours nos tests actuels \xe0 la fin, on sait que les usages actuels fonctionneront toujours\\n\\nCette discipline de modularisation des services et de r\xe9daction de tests est ce qui permet \xe0 Bimo d\'\xe9voluer rapidement sans r\xe9gressions !\\n\\n## \xc9pilogue\\n\\n2 semaines apr\xe8s avoir r\xe9dig\xe9 ce service, un nouveau besoin semblable est apparu, qui a conduit \xe0 cr\xe9er un nouveau service getBboxForPlaces (avec un s).\\n\\nEn effet, pour ce nouveau besoin, on veut une bBox autour de plusieurs lieux qui n\'ont pas n\xe9cessairement de lien entre eux.\\n\\nOn a donc transf\xe9r\xe9 le code de getBboxForPlace vers getBboxForPlaces, puis on l\'a modifi\xe9 un peu pour qu\'il accepte directement un array de lieux.\\n\\nD\xe9sormais, getBboxForPlace ne conserve que la logique qui construit un array de lieu avec les lieux enfants d\'un lieu de r\xe9f\xe9rence, puis fait appel \xe0 getBboxForPlaces.\\n\\nLes tests de getBboxForPlace restent les m\xeames, et passent toujours. On a facilement pu mutualiser du code, et gagner du temps ..."},{"id":"extraire-automatiquement-des-images-de-plans-de-voies-\xe0-partir-de-la-cartographie-hastus","metadata":{"permalink":"/examples/extraire-automatiquement-des-images-de-plans-de-voies-\xe0-partir-de-la-cartographie-hastus","source":"@site/examples/extraire-automatiquement-des-images-de-plans-de-voies-\xe0-partir-de-la-cartographie-hastus/index.mdx","title":"Extraire automatiquement des images de plans de voies \xe0 partir de la cartographie Hastus","description":"Origine du besoin","date":"2022-11-27T00:00:00.000Z","tags":[{"inline":true,"label":"hastus","permalink":"/examples/tags/hastus"},{"inline":true,"label":"cartographie","permalink":"/examples/tags/cartographie"},{"inline":true,"label":"geo","permalink":"/examples/tags/geo"},{"inline":true,"label":"mapshaper","permalink":"/examples/tags/mapshaper"},{"inline":true,"label":"lieux","permalink":"/examples/tags/lieux"}],"hasTruncateMarker":false,"authors":[{"name":"Ga\xebl Ham\xe9on","title":"Cr\xe9ateur de Bimo","url":"https://github.com/gaelhameon","imageURL":"https://github.com/gaelhameon.png","key":"gael"}],"frontMatter":{"slug":"extraire-automatiquement-des-images-de-plans-de-voies-\xe0-partir-de-la-cartographie-hastus","title":"Extraire automatiquement des images de plans de voies \xe0 partir de la cartographie Hastus","lead":"En utilisant des services Bimo et le projet Open Source Mapshaper, on arrive en moins d\'une centaine de lignes de code \xe0 \xe9crire un script assez puissant!","date":"2022-11-27","authors":["gael"],"tags":["hastus","cartographie","geo","mapshaper","lieux"],"hide_blog_post_date":true},"unlisted":false,"prevItem":{"title":"Cr\xe9er un nouveau service Bimo","permalink":"/examples/creation-du-service-get-bbox-for-place"}},"content":"import DescriptionProbleme from \'../../mdx-snippets/description-probleme-must-hastus/fr.mdx\';\\n\\n## Origine du besoin\\n\\n<DescriptionProbleme />\\n\\nUn [autre article](./r\xe9concilier-les-lieux-de-deux-syst\xe8mes-diff\xe9rents-avec-find-best-match-for-target-among-candidates/) d\xe9crira \xe9ventuellement comment des services Bimo ont \xe9t\xe9 utilis\xe9s pour initialiser ce travail, mais cela restera n\xe9anmoins toujours une initialisation : dans certains cas, on n\'arrive pas \xe0 faire le rapprochement entre les voies automatiquement, et il faut demander \xe0 un humain d\'intervenir.\\n\\nAfin de faciliter cette intervention, on souhaite mettre \xe0 disposition des humains en question une IHM qui affichera, pour une gare donn\xe9e:\\n\\n- la liste des voies disponibles dans le syst\xe8me SNCF maison\\n- la liste des voies disponibles dans Hastus\\n- les \xe9quivalences trouv\xe9es automatiquement par les algos\\n- une image du plan de voie de la gare dans Hastus, et de la position des voies Hastus sur ce plan de voie\\n\\nEn effet, il existe souvent plusieurs \\"alias\\" pour une m\xeame voie, et le nom de voie utilis\xe9 dans Hastus n\'est pas toujours celui avec lequel les utilisateurs sont le plus familier. En leur montrant \xe0 quelle voie correspond un nom sur le plan de voie, on facilite grandement le travail. On aurait pu aussi se contenter de dire aux utilisateurs d\'ouvrir la carte Hastus, et de trouver dans la carte la gare concern\xe9e \xe0 chaque fois. Mais cela aurait ajout\xe9 des manipulations et du temps \xe0 une t\xe2che d\xe9j\xe0 pas tr\xe8s amusante ... et mon r\xf4le sur ce projet est pr\xe9cis\xe9ment de m\'amuser \xe0 automatiser et acc\xe9l\xe9rer des manipulations pas tr\xe8s amusantes pour des humains.\\n\\n## Exploration des solutions\\n\\n### Processus global\\n\\nPour ne pas r\xe9inventer la roue, on consid\xe8re que l\'IHM qui sera pr\xe9sent\xe9e aux utilisateurs sera un fichier Excel par r\xe9gion, contenant un onglet pour chaque gare de la r\xe9gion. Sur cet onglet, on voudrait afficher le plan de voie, les listes de voies, et pr\xe9voir un endroit o\xf9 les utilisateurs pourront confirmer/corriger la correspondance.\\nCes fichiers pourront ensuite \xeatre relus automatiquement pour en extraire les correspondances valid\xe9es.\\n\\nOn souhaite donc produire des images de plan de voie \xe0 partir de la carte Hastus, dans un format qui pourra \xeatre incorpor\xe9 dans un fichier Excel.\\n\\nLes fonctionnalit\xe9s standard Hastus permettent d\'extraire la carte en format Shapefile et on conna\xeet un tr\xe8s bon outil open source pour manipuler des fichiers Shapefile: [mapshaper](https://mapshaper.org)\\n\\n<details>\\n\\n<summary>Note sur la s\xe9curit\xe9 des donn\xe9es</summary>\\n\\nPour ceux qui s\'inqui\xe9teraient de l\'utilisation d\'outils internet grand public pour la manipulation de donn\xe9es potentiellement sensibles, sachez que mapshaper traite toutes les donn\xe9es c\xf4t\xe9 client - jamais nos donn\xe9es ne quittent notre poste. Et si cela ne suffisait pas, j\'incorpore dans certaines distributions Bimo un \\"fork\\" de mapshaper qui pourrait vous rassurer encore plus: apr\xe8s avoir t\xe9l\xe9charg\xe9 Bimo, vous pouvez couper toute connexion internet, lancer Bimo et avoir une instance mapshaper qui tourne.\\n\\n</details>\\n\\nUne v\xe9rification rapide montre que mapshaper permet d\'exporter une carte au format `svg` et qu\'Excel permet d\'incorporer des images dans ce format.\\n\\nOn va donc utiliser mapshaper pour produire des `svg` de toutes les gares, puis on pourra incorporer ces svg dans les fichiers Excel.\\n\\n### Commandes mapshaper\\n\\nMapshaper peut \xeatre utilis\xe9 via l\'IHM web, mais fourni aussi un CLI node, d\xe9j\xe0 incorpor\xe9 dans le backend Bimo. Mais en plus, l\'IHM web permet d\'utiliser une console pour tester des commandes.\\n\\n![Manipulations pour afficher la console dans l\'IHM Mapshaper](images/mapshaper-console.gif)\\n\\nL\'aide est disponible directement dans la console, ou sur le repo Github du projet.\\n\\nOn y trouve la commande [clip](https://github.com/mbloch/mapshaper/wiki/Command-Reference#-clip), qui va permettre de produire un nouveau calque \xe0 partir d\'un calque existant, en conservant uniquement une zone d\xe9limit\xe9e par des coordonn\xe9es ou par une g\xe9om\xe9trie pr\xe9sente sur un autre calque.\\n\\nEn testant un peu, on conclut que la commande ci-dessous semble donner satisfaction. Notez bien l\'utilisation du \\"+\\" qui indique de cr\xe9er un nouveau calque, et donc de pr\xe9server le calque cible tel qu\'il \xe9tait. L\'argument \\"name\\" donne le nom du nouveau calque.\\n\\n`clip target=calque_initial bbox=xmin,ymin,xmax,ymax + name=clip_de_gare_1`\\n\\n![Exemple d\'application de la commande clip](images/commande-clip.gif)\\n\\n\xc7a marche tr\xe8s bien pour extraire la g\xe9om\xe9trie des voies \xe0 partir du mapshaper extrait d\'Hastus. Par contre les lieux-voies n\'apparaissent pas ... En effet, dans Hastus, les lieux sont des objets \xe0 part, qui sont associ\xe9s \xe0 des segments de la carte, mais n\'en font pas partie.\\n\\nOn devra donc obtenir un autre fichier contenant les donn\xe9es sur les lieux, et l\'importer en tant que calque suppl\xe9mentaire dans Mapshaper (ceci pourrait faire l\'objet d\'un autre article si \xe7a int\xe9resse quelqu\'un !).\\n\\n\xc0 ce stade, on arrive \xe0 produire une image dans laquelle on a les voies, ainsi que des points correspondant aux lieux. Mais il manque toujours les libell\xe9s.\\n\\nOn va donc utiliser la commande `style` de mapshaper pour les faire appara\xeetre.\\n\\n`style target=calque_des_lieux\\" label-text=\'plcIdentifier\' dx=5 dy=5 ...`\\n\\n![R\xe9sultat avec des libell\xe9s](images/test-avec-libelles.png)\\n\\n\xc7a commence \xe0 ressembler pas mal \xe0 ce qu\'on souhaite ! On va donc se lancer dans l\'automatisation.\\n\\n## Automatisation\\n\\nOn veut g\xe9n\xe9rer une image pour chaque gare et on souhaite que cette image englobe toutes les voies de la gare. Dans Hastus, on peut consid\xe9rer qu\'une gare est \xe0 peu pr\xe8s \xe9quivalente \xe0 \\"lieu de r\xe9f\xe9rence\\", qui n\'existe pas sur la carte, mais qui est associ\xe9 \xe0 plusieurs \\"lieux-voies\\", qui ont eux des coordonn\xe9es.\\n\\nOn va donc:\\n\\n- it\xe9rer sur tous les lieux de r\xe9f\xe9rence\\n  - pour chaque lieu de r\xe9f\xe9rence, r\xe9cup\xe9rer tout ses lieux-voies\\n    - \xe0 partir des coordonn\xe9es de tous les lieux-voies, calculer les coordonn\xe9es d\'une \\"Bounding Box\\"\\n    - prendre un clip des calques \\"voies\\" et \\"lieux-voies\\" avec cette bbox\\n    - g\xe9rer le style du clip pour ajouter les libell\xe9s\\n    - exporter le clip au format SVG, avec un nom de fichier correspondant \xe0 l\'identifiant de la gare\\n\\nOn n\'est pas sur un sujet r\xe9current ici, et on n\'a pas vraiment besoin que ce travail puisse \xeatre fait facilement par n\'importe quel utilisateur. On va donc tout simplement cr\xe9er un nouveau \\"script\\" dans Bimo, qui ne pourra \xeatre ex\xe9cut\xe9 que par les utilisateurs qui ont acc\xe8s au code source, et qui s\'appuiera sur les services et utilitaires Bimo existants, notamment:\\n\\n- `const { getEntityFromOirDataAtPath } = require(\'@bimo-test/utils-get-test-data\');` va permettre de charger facilement un jeu de lieux, puis d\'it\xe9rer sur les lieux de r\xe9f\xe9rence, obtenir leurs lieux-voies et leurs coordonn\xe9es\\n- `const { api: mapshaper } = require(\'@bimo/mapshaper\');` va permettre d\'int\xe9grer des commandes mapshaper dans notre script\\n\\n### Cr\xe9ation du service `getBboxForPlace`\\n\\nLe sujet du calcul d\'une Bbox pour un lieu est nouveau. Il est assez simple \xe0 premi\xe8re vue, mais:\\n\\n- c\'est exactement le genre de code dans lequel il est tr\xe8s facile d\'introduire des bugs par de mauvais copier/coller ou autre\\n- ce th\xe8me peut en r\xe9alit\xe9 \xeatre assez complexe:\\n  - quelles marges ajouter autour des coordonn\xe9es des lieux voies ?\\n  - pourrions-nous (pour d\'autres usages) vouloir passer directement un lieu voie, et avoir une bbox centr\xe9e autour de celui-ci ?\\n  - et si on voulait un jour une bbox d\'une autre forme ? Un cercle, ou un rectangle orient\xe9 \xe0 45 degr\xe9s\\n\\nOn va donc cr\xe9er un nouveau service Bimo, avec des tests unitaires, pour ce sujet. Cela peut sembler \xeatre une perte de temps \xe0 court terme, mais devrait nous en faire gagner \xe0 long terme.\\n\\n{/* Voir <ArticleLink slug=\\"creation-du-service-get-bbox-for-place\\">cet article</ArticleLink> */}\\n\\n### Cr\xe9ation du script `generate-station-svg`\\n\\nOn a maintenant tous les services de base dont on a besoin pour notre script, dont vous trouverez ci-dessous une version simplifi\xe9e et comment\xe9e du code final.\\n\\n```javascript title=\\"script.js\\"\\nconst path = require(\'path\');\\nconst { fsBimo } = require(\'@bimo/core-utils-filesystem\'); // Un package qui nous aide \xe0 interagir avec le syst\xe8me de fichier\\nconst { api: mapshaper } = require(\'@bimo/mapshaper\'); // La fork \\"bimo\\" de mapshaper\\n\\nconst {\\n  getEntityFromOirDataAtPath,\\n} = require(\'@bimo/test-utils-get-test-data\'); // Une fonction pour simplifier le chargement de donn\xe9es oig/oir\\nconst getBboxForPlace = require(\'@bimo/core-services-get-bbox-for-place\'); // le script qu\'on a \xe9crit \xe0 l\'\xe9tape pr\xe9c\xe9dente!\\nconst { featureCollection } = require(\'@turf/helpers\'); // un package externe qui aide \xe0 manipuler des geojson\\n\\nconst createGeojsonFeatureFromPlace = require(\'@bimo/core-services-create-geojson-feature-from-place\');\\n// un package interne qui aide \xe0 cr\xe9er des geojson \xe0 partir de lieux\\n\\nconst { PlacesCollection } = require(\'@bimo/core-entities\');\\n// La classe qui d\xe9finit un jeu de lieux\\n\\nconst PATH_TO_PLACES_COLLECTION_FOLDER = path.join(\\n  __dirname,\\n  \'input\',\\n  \'places-collection\'\\n);\\n// On d\xe9finit un dossier d\'entr\xe9e dans lequel l\'utilisateur devra d\xe9poser\\n// une extraction des lieux d\'un environnement Hastus, et le fichier OIR\\n// qui d\xe9crit le format de l\'extraction...\\n\\nconst PATH_TO_TRACKS_MAP = path.join(\\n  __dirname,\\n  \'input\',\\n  \'tracks-map\',\\n  \'tracks.geojson\'\\n);\\n// ... et un fichier correspondant \xe0 une carte des voies (obtenue soit depuis Hastus, ou une autre source)\\n\\nconst PATH_TO_FULL_PLACES_COLLECTION_MAP = path.join(\\n  __dirname,\\n  \'output\',\\n  \'places-map\',\\n  \'places.geojson\'\\n);\\n// c\'est ici que le script d\xe9posera la carte des lieux produite \xe0 partir du jeu de lieux\\n\\nasync function main() {\\n  const startTime = new Date(); // pour mesurer le temps \xe9coul\xe9 \xe0 la fin\\n\\n  // \xc9tape 1: on va cr\xe9er une carte repr\xe9sentant tous les lieux voies et\\n  // l\'exporter \xe0 un endroit o\xf9 mapshaper pourra ensuite aller la charger\\n  const placesCollection = await getEntityFromOirDataAtPath(\\n    PATH_TO_PLACES_COLLECTION_FOLDER,\\n    OscarPlacesCollection\\n  );\\n\\n  await fsBimo.outputJSON(\\n    PATH_TO_FULL_PLACES_COLLECTION_MAP,\\n    createPlacesFeatureCollection(placesCollection)\\n  ); // voir \xe0 la fin du script pour la d\xe9finition de createPlacesFeatureCollection\\n\\n  // \xc9tape 2: on va maintenant fabriquer les commandes que l\'on va soumettre\\n  // \xe0 mapshaper\\n  const commandLines = [\\n    `-i ${PATH_TO_FULL_PLACES_COLLECTION_MAP} name=places`,\\n    `-i ${PATH_TO_TRACKS_MAP} name=tracks`,\\n    `-style target=places r=4 label-text=\'plcIdentifier\' text-anchor=start dx=10 dy=10 fill=red`,\\n  ];\\n  // on commence par charger la carte des lieux et la carte des voies, et on\\n  // applique un style global \xe0 la carte des lieux:\\n  // on va afficher un cercle de rayon 4 sur chaque lieu, avec \xe0 c\xf4t\xe9 un\\n  // libell\xe9 contenant le \\"plcIdentifier\\", d\xe9cal\xe9 de 10\\n  // par rapport au point, et affich\xe9 en rouge\\n\\n  placesCollection\\n    .placesByReferencePlace()\\n    .forEach((places, referencePlace) => {\\n      // On parcourt tous les PR du jeu de lieux, et pour chacun:\\n\\n      const { plcIdentifier } = referencePlace;\\n\\n      const pathToOutput = path.join(\\n        __dirname,\\n        \'output\',\\n        \'svgs\',\\n        `${plcIdentifier}.svg`\\n      );\\n      // on va produire un fichier nomm\xe9 selon l\'ID de lieu\\n\\n      const bBoxString =\\n        getBboxForPlace(referencePlace).getMapshaperStyleString();\\n      // on calcule la \\"Bounding Box\\" qui englobe tous les lieux voies\\n\\n      commandLines.push(\\n        `-clip target=places bbox=${bBoxString} + name=${plcIdentifier}_1`,\\n        `-clip target=tracks bbox=${bBoxString} + name=${plcIdentifier}_2`,\\n        // on prend des clips des deux cartes, aux mesures de la bounding box\\n\\n        `-o target=${plcIdentifier}_1,${plcIdentifier}_2 ${pathToOutput}`,\\n        // on exporte ces clips sous forme de .svg\\n\\n        `-drop target=${plcIdentifier}_1,${plcIdentifier}_2`\\n        // on supprime les clips pour \xe9viter de surcharger la m\xe9moire\\n      );\\n    });\\n\\n  // \xe0 l\'issue de cette boucle, commandeLines contient:\\n  // - les 3 commandes initiales permettant de charger et styliser les donn\xe9es\\n  // - x commandes permettant de g\xe9n\xe9rer, exporter et supprimer les clips pour chaque gare\\n\\n  await mapshaper.runCommands(commandLines.join(\'\\\\n\'));\\n  // on balance toutes les commandes \xe0 mapshaper et on attend ...\\n\\n  console.log(`Done in ${(new Date() - startTime) / 1000} seconds`);\\n  // Et voil\xe0 !\\n}\\n\\nfunction createPlacesFeatureCollection(placesCollection) {\\n  // cette fonction est relativement simple: on utilise le service existant \\"createGeojsonFeatureFromPlace\\"\\n  // pour cr\xe9er, pour chaque lieu, un objet \\"point\\" en geojson, qui permettra de constituer une carte de tous\\n  // les lieux voies\\n  const placeFeatures = [];\\n  placesCollection.forEach((place) => {\\n    if (place.isLocated) {\\n      try {\\n        placeFeatures.push(createGeojsonFeatureFromPlace(place));\\n      } catch (error) {\\n        console.log(\\n          `Erreur lors de la cr\xe9ation de la feature correspondant au lieu ${place.slo}: ${error}`\\n        );\\n      }\\n    }\\n  });\\n  return featureCollection(placeFeatures);\\n}\\n\\n// on lance la fonction principale\\nmain();\\n```\\n\\nEt voil\xe0 ! En s\'appuyant sur des services Bimo r\xe9utilisables et sur la librairie Open Source [mapshaper](https://mapshaper.org), on arrive, en moins d\'une centaine de lignes de codes, \xe0 \xe9crire un script assez puissant, qui nous donne des images semblables \xe0 celle-ci:\\n\\n![Exemple d\'image produite par le script](images/exemple-svg-gare.svg)\\n\\nOn peut \xe9ventuellement le raffiner, ajuster le style des libell\xe9s des lieux, par exemple, ou la couleur des voies etc.\\n\\nOn peut \xe9galement se poser la question de la performance: \xe0 l\'heure actuelle, pour chaque gare, mapshaper doit faire un clip de l\'\xe9norme carte de la France enti\xe8re, ce qui repr\xe9sente pas mal de travail. Avec cette version de base, il aurait fallu laisser tourner le script un peu moins de deux heures pour produire des images des quelques 5000 gares qui pouvaient nous int\xe9resser.\\n\\nCe n\'est pas r\xe9dhibitoire, mais quand m\xeame pas tr\xe8s pratique.\\n\\nDans un prochain article, on verra comment on a pu am\xe9liorer les performances pour descendre de 2h \xe0 moins de 10 minutes !\\n {/* am\xe9liorer-les-performances-de-scripts-manipulant-des-donn\xe9es-g\xe9ographiques */}"}]}}')}}]);